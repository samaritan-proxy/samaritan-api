// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: config/service/config.proto

package service

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	common "github.com/samaritan-proxy/samaritan-api/go/common"
	hc "github.com/samaritan-proxy/samaritan-api/go/config/hc"
	protocol "github.com/samaritan-proxy/samaritan-api/go/config/protocol"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Load balance policy.
type LoadBalancePolicy int32

const (
	// RoundRobin
	LoadBalancePolicy_ROUND_ROBIN LoadBalancePolicy = 0
	// LeastConnection
	LoadBalancePolicy_LEAST_CONNECTION LoadBalancePolicy = 1
	// Random
	LoadBalancePolicy_RANDOM LoadBalancePolicy = 2
	// Provided by redis cluster
	LoadBalancePolicy_CLUSTER_PROVIDED LoadBalancePolicy = 3
)

var LoadBalancePolicy_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONNECTION",
	2: "RANDOM",
	3: "CLUSTER_PROVIDED",
}

var LoadBalancePolicy_value = map[string]int32{
	"ROUND_ROBIN":      0,
	"LEAST_CONNECTION": 1,
	"RANDOM":           2,
	"CLUSTER_PROVIDED": 3,
}

func (x LoadBalancePolicy) String() string {
	return proto.EnumName(LoadBalancePolicy_name, int32(x))
}

func (LoadBalancePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a9b55a1cfb1b6f6f, []int{0}
}

// Listener configuration.
type Listener struct {
	// The address that the listener should listen on, must be set.
	Address *common.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// The limit of connections, new connections that exceed this value are immediately be closed.
	// Default value is 0 that the limit will be disable.
	ConnectionLimit      uint32   `protobuf:"varint,2,opt,name=connection_limit,json=connectionLimit,proto3" json:"connection_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Listener) Reset()         { *m = Listener{} }
func (m *Listener) String() string { return proto.CompactTextString(m) }
func (*Listener) ProtoMessage()    {}
func (*Listener) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9b55a1cfb1b6f6f, []int{0}
}
func (m *Listener) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Listener) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Listener.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Listener) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Listener.Merge(m, src)
}
func (m *Listener) XXX_Size() int {
	return m.Size()
}
func (m *Listener) XXX_DiscardUnknown() {
	xxx_messageInfo_Listener.DiscardUnknown(m)
}

var xxx_messageInfo_Listener proto.InternalMessageInfo

func (m *Listener) GetAddress() *common.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Listener) GetConnectionLimit() uint32 {
	if m != nil {
		return m.ConnectionLimit
	}
	return 0
}

// Configuration of service,
// contains configuration information required for the processor to run.
type Config struct {
	// Listener config, must be set.
	Listener *Listener `protobuf:"bytes,1,opt,name=listener,proto3" json:"listener,omitempty"`
	// Health check will be disabled when not defined.
	HealthCheck *hc.HealthCheck `protobuf:"bytes,2,opt,name=health_check,json=healthCheck,proto3" json:"health_check,omitempty"`
	// The maximum time to wait for a connection attempt to a server to succeed, default is 3s.
	ConnectTimeout *time.Duration `protobuf:"bytes,3,opt,name=connect_timeout,json=connectTimeout,proto3,stdduration" json:"connect_timeout,omitempty"`
	// The maximum inactivity time on the client side, default is 10min.
	IdleTimeout *time.Duration    `protobuf:"bytes,4,opt,name=idle_timeout,json=idleTimeout,proto3,stdduration" json:"idle_timeout,omitempty"`
	LbPolicy    LoadBalancePolicy `protobuf:"varint,5,opt,name=lb_policy,json=lbPolicy,proto3,enum=service.LoadBalancePolicy" json:"lb_policy,omitempty"`
	// Protocol of service, can not be UNKNOWN.
	Protocol protocol.Protocol `protobuf:"varint,6,opt,name=protocol,proto3,enum=protocol.Protocol" json:"protocol,omitempty"`
	// Types that are valid to be assigned to ProtocolOptions:
	//	*Config_TcpOption
	//	*Config_RedisOption
	//	*Config_MysqlOption
	ProtocolOptions      isConfig_ProtocolOptions `protobuf_oneof:"protocol_options"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_a9b55a1cfb1b6f6f, []int{1}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

type isConfig_ProtocolOptions interface {
	isConfig_ProtocolOptions()
	Equal(interface{}) bool
	VerboseEqual(interface{}) error
	MarshalTo([]byte) (int, error)
	Size() int
}

type Config_TcpOption struct {
	TcpOption *protocol.TCPOption `protobuf:"bytes,7,opt,name=tcp_option,json=tcpOption,proto3,oneof"`
}
type Config_RedisOption struct {
	RedisOption *protocol.RedisOption `protobuf:"bytes,8,opt,name=redis_option,json=redisOption,proto3,oneof"`
}
type Config_MysqlOption struct {
	MysqlOption *protocol.MySQLOption `protobuf:"bytes,9,opt,name=mysql_option,json=mysqlOption,proto3,oneof"`
}

func (*Config_TcpOption) isConfig_ProtocolOptions()   {}
func (*Config_RedisOption) isConfig_ProtocolOptions() {}
func (*Config_MysqlOption) isConfig_ProtocolOptions() {}

func (m *Config) GetProtocolOptions() isConfig_ProtocolOptions {
	if m != nil {
		return m.ProtocolOptions
	}
	return nil
}

func (m *Config) GetListener() *Listener {
	if m != nil {
		return m.Listener
	}
	return nil
}

func (m *Config) GetHealthCheck() *hc.HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *Config) GetConnectTimeout() *time.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *Config) GetIdleTimeout() *time.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *Config) GetLbPolicy() LoadBalancePolicy {
	if m != nil {
		return m.LbPolicy
	}
	return LoadBalancePolicy_ROUND_ROBIN
}

func (m *Config) GetProtocol() protocol.Protocol {
	if m != nil {
		return m.Protocol
	}
	return protocol.UNKNOWN
}

func (m *Config) GetTcpOption() *protocol.TCPOption {
	if x, ok := m.GetProtocolOptions().(*Config_TcpOption); ok {
		return x.TcpOption
	}
	return nil
}

func (m *Config) GetRedisOption() *protocol.RedisOption {
	if x, ok := m.GetProtocolOptions().(*Config_RedisOption); ok {
		return x.RedisOption
	}
	return nil
}

func (m *Config) GetMysqlOption() *protocol.MySQLOption {
	if x, ok := m.GetProtocolOptions().(*Config_MysqlOption); ok {
		return x.MysqlOption
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Config) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Config_TcpOption)(nil),
		(*Config_RedisOption)(nil),
		(*Config_MysqlOption)(nil),
	}
}

func init() {
	proto.RegisterEnum("service.LoadBalancePolicy", LoadBalancePolicy_name, LoadBalancePolicy_value)
	proto.RegisterType((*Listener)(nil), "service.Listener")
	proto.RegisterType((*Config)(nil), "service.Config")
}

func init() { proto.RegisterFile("config/service/config.proto", fileDescriptor_a9b55a1cfb1b6f6f) }

var fileDescriptor_a9b55a1cfb1b6f6f = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xcd, 0xa4, 0x6d, 0x9a, 0x4e, 0x4a, 0xeb, 0x0e, 0x45, 0x84, 0x22, 0x99, 0xa8, 0xab, 0x52,
	0x09, 0x5b, 0x2a, 0x2f, 0xd1, 0x5d, 0xf3, 0x90, 0x5a, 0x29, 0x8d, 0xc3, 0x34, 0x45, 0x08, 0x21,
	0x59, 0xce, 0x78, 0x1a, 0x8f, 0x98, 0x78, 0x8c, 0x3d, 0xa9, 0xc8, 0x96, 0x25, 0x5f, 0xc0, 0x27,
	0x20, 0x3e, 0x81, 0x15, 0x4b, 0x96, 0xfd, 0x03, 0xda, 0xac, 0x60, 0xd7, 0x4f, 0x40, 0x1e, 0x8f,
	0x63, 0x15, 0x56, 0xec, 0xee, 0x39, 0x73, 0xce, 0xbd, 0x67, 0xe6, 0xca, 0x86, 0xf7, 0x89, 0x08,
	0xcf, 0xd8, 0xc8, 0x4e, 0x68, 0x7c, 0xce, 0x08, 0xb5, 0x33, 0x68, 0x45, 0xb1, 0x90, 0x02, 0x2d,
	0x6b, 0x76, 0xcb, 0x1c, 0x09, 0x31, 0xe2, 0xd4, 0x56, 0xf4, 0x70, 0x72, 0x66, 0xfb, 0x93, 0xd8,
	0x93, 0x4c, 0x84, 0x99, 0x70, 0x6b, 0x73, 0x24, 0x46, 0x42, 0x95, 0x76, 0x5a, 0x69, 0xf6, 0xee,
	0xb9, 0xc7, 0x99, 0xef, 0x49, 0x6a, 0xe7, 0x45, 0x2e, 0x27, 0x62, 0x3c, 0x16, 0xa1, 0xed, 0xf9,
	0x7e, 0x4c, 0x93, 0x44, 0xb3, 0x48, 0x47, 0x09, 0x88, 0x1d, 0x10, 0xcd, 0x99, 0x9a, 0x53, 0x88,
	0x08, 0x3e, 0x2f, 0xb2, 0xf3, 0x6d, 0x0e, 0xab, 0x5d, 0x96, 0x48, 0x1a, 0xd2, 0x18, 0x3d, 0x85,
	0xcb, 0xba, 0x61, 0x1d, 0x34, 0xc0, 0x4e, 0x6d, 0x6f, 0xdd, 0xca, 0xe6, 0x58, 0x07, 0x19, 0xdd,
	0x84, 0xdf, 0x7e, 0x7f, 0x5f, 0x58, 0xfa, 0x04, 0xca, 0x06, 0xc0, 0xb9, 0x16, 0x3d, 0x84, 0x06,
	0x11, 0x61, 0x48, 0x49, 0x7a, 0x1f, 0x97, 0xb3, 0x31, 0x93, 0xf5, 0x72, 0x03, 0xec, 0xdc, 0xc2,
	0xeb, 0x05, 0xdf, 0x4d, 0xe9, 0xed, 0x8b, 0x45, 0x58, 0x69, 0xa9, 0x40, 0xe8, 0x05, 0xac, 0x72,
	0x3d, 0x58, 0x4f, 0xdb, 0xb0, 0xf4, 0x6b, 0x59, 0x79, 0xa2, 0x1b, 0xf3, 0xe6, 0x72, 0xb4, 0x07,
	0x57, 0x03, 0xea, 0x71, 0x19, 0xb8, 0x24, 0xa0, 0xe4, 0x9d, 0x1a, 0x96, 0x86, 0x0d, 0x88, 0x75,
	0xa8, 0xf8, 0x56, 0x4a, 0xe3, 0x5a, 0x50, 0x00, 0x84, 0x61, 0x1e, 0xc6, 0x95, 0x6c, 0x4c, 0xc5,
	0x44, 0xd6, 0x17, 0x94, 0xed, 0x9e, 0x95, 0xad, 0xc6, 0xca, 0x57, 0x63, 0xb5, 0xf5, 0x6a, 0x9a,
	0x6b, 0x9f, 0x7f, 0x3e, 0x00, 0x2a, 0xc1, 0x57, 0x50, 0xde, 0x2d, 0xe1, 0x35, 0xdd, 0x61, 0x90,
	0x35, 0x40, 0x5d, 0xb8, 0xca, 0x7c, 0x4e, 0xe7, 0x0d, 0x17, 0xff, 0xb7, 0x61, 0x2d, 0xb5, 0xe7,
	0xdd, 0x9e, 0xc3, 0x15, 0x3e, 0x74, 0x23, 0xc1, 0x19, 0x99, 0xd6, 0x97, 0x1a, 0x60, 0x67, 0x6d,
	0x6f, 0xab, 0x78, 0x11, 0xe1, 0xf9, 0x4d, 0x8f, 0x7b, 0x21, 0xa1, 0x7d, 0xa5, 0xc0, 0x55, 0x3e,
	0xcc, 0x2a, 0xb4, 0x0f, 0xab, 0xf9, 0x52, 0xeb, 0x15, 0xe5, 0x43, 0xd6, 0x7c, 0xcb, 0x7d, 0x5d,
	0xe8, 0xa7, 0xfc, 0x08, 0xca, 0x8d, 0x12, 0x9e, 0xeb, 0xd1, 0x13, 0x08, 0x25, 0x89, 0x5c, 0x11,
	0xa5, 0xf9, 0xea, 0xcb, 0xea, 0x02, 0xb7, 0x0b, 0xf7, 0xa0, 0xd5, 0x77, 0xd4, 0xd1, 0x61, 0x09,
	0xaf, 0x48, 0x12, 0x65, 0x00, 0xed, 0xc3, 0xd5, 0x98, 0xfa, 0x2c, 0xc9, 0x7d, 0x55, 0xe5, 0xbb,
	0x53, 0xf8, 0x70, 0x7a, 0x3a, 0x77, 0xd6, 0xe2, 0x02, 0xa6, 0xde, 0xf1, 0x34, 0x79, 0xcf, 0x73,
	0xef, 0xca, 0xdf, 0xde, 0xe3, 0xe9, 0xc9, 0xcb, 0x6e, 0xe1, 0x55, 0xe2, 0x0c, 0x36, 0x11, 0x34,
	0x72, 0x99, 0xb6, 0x27, 0xbb, 0x6f, 0xe1, 0xc6, 0x3f, 0x8f, 0x83, 0xd6, 0x61, 0x0d, 0x3b, 0xa7,
	0xbd, 0xb6, 0x8b, 0x9d, 0xe6, 0x51, 0xcf, 0x28, 0xa1, 0x4d, 0x68, 0x74, 0x3b, 0x07, 0x27, 0x03,
	0xb7, 0xe5, 0xf4, 0x7a, 0x9d, 0xd6, 0xe0, 0xc8, 0xe9, 0x19, 0x00, 0x41, 0x58, 0xc1, 0x07, 0xbd,
	0xb6, 0x73, 0x6c, 0x94, 0x53, 0x45, 0xab, 0x7b, 0x7a, 0x32, 0xe8, 0x60, 0xb7, 0x8f, 0x9d, 0x57,
	0x47, 0xed, 0x4e, 0xdb, 0x58, 0x68, 0xbe, 0xbe, 0xbc, 0x32, 0xc1, 0xf5, 0x95, 0x09, 0xbe, 0xcc,
	0x4c, 0xf0, 0x63, 0x66, 0x82, 0x8b, 0x99, 0x09, 0x2e, 0x67, 0x26, 0xf8, 0x35, 0x33, 0xc1, 0xf5,
	0xcc, 0x2c, 0xbd, 0x79, 0x36, 0x62, 0x32, 0x98, 0x0c, 0xd3, 0x2f, 0xc5, 0x4e, 0xbc, 0xb1, 0x17,
	0x33, 0xe9, 0x85, 0x8f, 0xa2, 0x58, 0x7c, 0x98, 0x16, 0xd8, 0x8e, 0x86, 0xf6, 0xcd, 0xff, 0xc4,
	0xb0, 0xa2, 0x6e, 0xf2, 0xf8, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xa6, 0x6c, 0x85, 0x40,
	0x04, 0x00, 0x00,
}

func (this *Listener) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Listener)
	if !ok {
		that2, ok := that.(Listener)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Listener")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Listener but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Listener but is not nil && this == nil")
	}
	if !this.Address.Equal(that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.ConnectionLimit != that1.ConnectionLimit {
		return fmt.Errorf("ConnectionLimit this(%v) Not Equal that(%v)", this.ConnectionLimit, that1.ConnectionLimit)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Listener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener)
	if !ok {
		that2, ok := that.(Listener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Address.Equal(that1.Address) {
		return false
	}
	if this.ConnectionLimit != that1.ConnectionLimit {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Config) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Config)
	if !ok {
		that2, ok := that.(Config)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Config")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Config but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Config but is not nil && this == nil")
	}
	if !this.Listener.Equal(that1.Listener) {
		return fmt.Errorf("Listener this(%v) Not Equal that(%v)", this.Listener, that1.Listener)
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return fmt.Errorf("HealthCheck this(%v) Not Equal that(%v)", this.HealthCheck, that1.HealthCheck)
	}
	if this.ConnectTimeout != nil && that1.ConnectTimeout != nil {
		if *this.ConnectTimeout != *that1.ConnectTimeout {
			return fmt.Errorf("ConnectTimeout this(%v) Not Equal that(%v)", *this.ConnectTimeout, *that1.ConnectTimeout)
		}
	} else if this.ConnectTimeout != nil {
		return fmt.Errorf("this.ConnectTimeout == nil && that.ConnectTimeout != nil")
	} else if that1.ConnectTimeout != nil {
		return fmt.Errorf("ConnectTimeout this(%v) Not Equal that(%v)", this.ConnectTimeout, that1.ConnectTimeout)
	}
	if this.IdleTimeout != nil && that1.IdleTimeout != nil {
		if *this.IdleTimeout != *that1.IdleTimeout {
			return fmt.Errorf("IdleTimeout this(%v) Not Equal that(%v)", *this.IdleTimeout, *that1.IdleTimeout)
		}
	} else if this.IdleTimeout != nil {
		return fmt.Errorf("this.IdleTimeout == nil && that.IdleTimeout != nil")
	} else if that1.IdleTimeout != nil {
		return fmt.Errorf("IdleTimeout this(%v) Not Equal that(%v)", this.IdleTimeout, that1.IdleTimeout)
	}
	if this.LbPolicy != that1.LbPolicy {
		return fmt.Errorf("LbPolicy this(%v) Not Equal that(%v)", this.LbPolicy, that1.LbPolicy)
	}
	if this.Protocol != that1.Protocol {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if that1.ProtocolOptions == nil {
		if this.ProtocolOptions != nil {
			return fmt.Errorf("this.ProtocolOptions != nil && that1.ProtocolOptions == nil")
		}
	} else if this.ProtocolOptions == nil {
		return fmt.Errorf("this.ProtocolOptions == nil && that1.ProtocolOptions != nil")
	} else if err := this.ProtocolOptions.VerboseEqual(that1.ProtocolOptions); err != nil {
		return err
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Config_TcpOption) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Config_TcpOption)
	if !ok {
		that2, ok := that.(Config_TcpOption)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Config_TcpOption")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Config_TcpOption but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Config_TcpOption but is not nil && this == nil")
	}
	if !this.TcpOption.Equal(that1.TcpOption) {
		return fmt.Errorf("TcpOption this(%v) Not Equal that(%v)", this.TcpOption, that1.TcpOption)
	}
	return nil
}
func (this *Config_RedisOption) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Config_RedisOption)
	if !ok {
		that2, ok := that.(Config_RedisOption)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Config_RedisOption")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Config_RedisOption but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Config_RedisOption but is not nil && this == nil")
	}
	if !this.RedisOption.Equal(that1.RedisOption) {
		return fmt.Errorf("RedisOption this(%v) Not Equal that(%v)", this.RedisOption, that1.RedisOption)
	}
	return nil
}
func (this *Config_MysqlOption) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Config_MysqlOption)
	if !ok {
		that2, ok := that.(Config_MysqlOption)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Config_MysqlOption")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Config_MysqlOption but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Config_MysqlOption but is not nil && this == nil")
	}
	if !this.MysqlOption.Equal(that1.MysqlOption) {
		return fmt.Errorf("MysqlOption this(%v) Not Equal that(%v)", this.MysqlOption, that1.MysqlOption)
	}
	return nil
}
func (this *Config) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config)
	if !ok {
		that2, ok := that.(Config)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Listener.Equal(that1.Listener) {
		return false
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return false
	}
	if this.ConnectTimeout != nil && that1.ConnectTimeout != nil {
		if *this.ConnectTimeout != *that1.ConnectTimeout {
			return false
		}
	} else if this.ConnectTimeout != nil {
		return false
	} else if that1.ConnectTimeout != nil {
		return false
	}
	if this.IdleTimeout != nil && that1.IdleTimeout != nil {
		if *this.IdleTimeout != *that1.IdleTimeout {
			return false
		}
	} else if this.IdleTimeout != nil {
		return false
	} else if that1.IdleTimeout != nil {
		return false
	}
	if this.LbPolicy != that1.LbPolicy {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if that1.ProtocolOptions == nil {
		if this.ProtocolOptions != nil {
			return false
		}
	} else if this.ProtocolOptions == nil {
		return false
	} else if !this.ProtocolOptions.Equal(that1.ProtocolOptions) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Config_TcpOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config_TcpOption)
	if !ok {
		that2, ok := that.(Config_TcpOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TcpOption.Equal(that1.TcpOption) {
		return false
	}
	return true
}
func (this *Config_RedisOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config_RedisOption)
	if !ok {
		that2, ok := that.(Config_RedisOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedisOption.Equal(that1.RedisOption) {
		return false
	}
	return true
}
func (this *Config_MysqlOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Config_MysqlOption)
	if !ok {
		that2, ok := that.(Config_MysqlOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MysqlOption.Equal(that1.MysqlOption) {
		return false
	}
	return true
}
func (this *Listener) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&service.Listener{")
	if this.Address != nil {
		s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	}
	s = append(s, "ConnectionLimit: "+fmt.Sprintf("%#v", this.ConnectionLimit)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Config) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&service.Config{")
	if this.Listener != nil {
		s = append(s, "Listener: "+fmt.Sprintf("%#v", this.Listener)+",\n")
	}
	if this.HealthCheck != nil {
		s = append(s, "HealthCheck: "+fmt.Sprintf("%#v", this.HealthCheck)+",\n")
	}
	s = append(s, "ConnectTimeout: "+fmt.Sprintf("%#v", this.ConnectTimeout)+",\n")
	s = append(s, "IdleTimeout: "+fmt.Sprintf("%#v", this.IdleTimeout)+",\n")
	s = append(s, "LbPolicy: "+fmt.Sprintf("%#v", this.LbPolicy)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	if this.ProtocolOptions != nil {
		s = append(s, "ProtocolOptions: "+fmt.Sprintf("%#v", this.ProtocolOptions)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Config_TcpOption) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service.Config_TcpOption{` +
		`TcpOption:` + fmt.Sprintf("%#v", this.TcpOption) + `}`}, ", ")
	return s
}
func (this *Config_RedisOption) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service.Config_RedisOption{` +
		`RedisOption:` + fmt.Sprintf("%#v", this.RedisOption) + `}`}, ", ")
	return s
}
func (this *Config_MysqlOption) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&service.Config_MysqlOption{` +
		`MysqlOption:` + fmt.Sprintf("%#v", this.MysqlOption) + `}`}, ", ")
	return s
}
func valueToGoStringConfig(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Listener) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Listener) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Listener) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectionLimit != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.ConnectionLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProtocolOptions != nil {
		{
			size := m.ProtocolOptions.Size()
			i -= size
			if _, err := m.ProtocolOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Protocol != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x30
	}
	if m.LbPolicy != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.LbPolicy))
		i--
		dAtA[i] = 0x28
	}
	if m.IdleTimeout != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.IdleTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.IdleTimeout):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintConfig(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x22
	}
	if m.ConnectTimeout != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdDurationMarshalTo(*m.ConnectTimeout, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(*m.ConnectTimeout):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintConfig(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x1a
	}
	if m.HealthCheck != nil {
		{
			size, err := m.HealthCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Listener != nil {
		{
			size, err := m.Listener.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config_TcpOption) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Config_TcpOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TcpOption != nil {
		{
			size, err := m.TcpOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Config_RedisOption) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Config_RedisOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RedisOption != nil {
		{
			size, err := m.RedisOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Config_MysqlOption) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Config_MysqlOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MysqlOption != nil {
		{
			size, err := m.MysqlOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Listener) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ConnectionLimit != 0 {
		n += 1 + sovConfig(uint64(m.ConnectionLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Listener != nil {
		l = m.Listener.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.HealthCheck != nil {
		l = m.HealthCheck.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.ConnectTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.ConnectTimeout)
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.IdleTimeout != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdDuration(*m.IdleTimeout)
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.LbPolicy != 0 {
		n += 1 + sovConfig(uint64(m.LbPolicy))
	}
	if m.Protocol != 0 {
		n += 1 + sovConfig(uint64(m.Protocol))
	}
	if m.ProtocolOptions != nil {
		n += m.ProtocolOptions.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Config_TcpOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TcpOption != nil {
		l = m.TcpOption.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}
func (m *Config_RedisOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RedisOption != nil {
		l = m.RedisOption.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}
func (m *Config_MysqlOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MysqlOption != nil {
		l = m.MysqlOption.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	return n
}

func sovConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Listener) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Listener: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Listener: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &common.Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionLimit", wireType)
			}
			m.ConnectionLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listener", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Listener == nil {
				m.Listener = &Listener{}
			}
			if err := m.Listener.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &hc.HealthCheck{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectTimeout == nil {
				m.ConnectTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.ConnectTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdleTimeout == nil {
				m.IdleTimeout = new(time.Duration)
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(m.IdleTimeout, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LbPolicy", wireType)
			}
			m.LbPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LbPolicy |= LoadBalancePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= protocol.Protocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &protocol.TCPOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProtocolOptions = &Config_TcpOption{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedisOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &protocol.RedisOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProtocolOptions = &Config_RedisOption{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MysqlOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &protocol.MySQLOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ProtocolOptions = &Config_MysqlOption{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthConfig
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig   = fmt.Errorf("proto: integer overflow")
)
